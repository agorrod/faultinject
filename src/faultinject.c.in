#include "config.h"

#undef _FILE_OFFSET_BITS
#undef __USE_FILE_OFFSET64
#undef _GNU_SOURCE
#define _GNU_SOURCE
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <execinfo.h>
#include <fcntl.h>

/* Need to tell libunwind to provide local only functionality */
#define UNW_LOCAL_ONLY
#include <libunwind.h>

#include <pthread.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#define	FAULT_INJECT_API	__attribute__ ((visibility("default")))

/*
 * Save references to the C library implementations of the functions we are
 * overriding.
 */
@TYPEDEFS@

@FUNCTION_DECLARATIONS@

static char *g_library_trace_substring = NULL;
static uint64_t g_op_count = 0;
static uint64_t g_max_op_count = 0;

@GLOBAL_CONFIG_DECLARATIONS@

void __attribute__ ((constructor)) faultinject_constructor(void);

/*
 * Setup pointers to the C library version of functions we are overriding,
 * and initialize any global variables.
 */
void __attribute__ ((constructor)) faultinject_constructor(void)
{
	char *env_string, *err_string;

	env_string = err_string = NULL;
	errno = 0;

	fprintf(stderr, "Setting up fault injector\n");
@CONSTRUCTOR_ASSIGNMENTS@

	if ((env_string = getenv("FAULTINJECT_LIBRARY_NAME")) != NULL &&
	    strlen(env_string) != 0) {
		g_library_trace_substring = env_string;
	}

	if ((env_string = getenv("FAULTINJECT_FAIL_COUNT")) != NULL &&
	    strlen(env_string) != 0) {
		errno = 0;
		g_max_op_count = strtoull(env_string, NULL, 10);
		printf("Set max op count to: %d\n", (int)g_max_op_count);
		if (errno != 0) {
			fprintf(stderr, "Failed to parse environment variable\n");
			g_max_op_count = 0;
		}
	}
	/* Function specific environment variable configuration parsing. */
@CONSTRUCTOR_CONFIG@
}

static int faultinject_fail_operation(void)
{
	if (!libc_open)
		faultinject_constructor();

	if (g_max_op_count > 0 && ++g_op_count > g_max_op_count) {
		printf("failing with op count: %d\n", (int)g_op_count);
		return (EFAULT);
	}

@OPERATION_CHECK@

	return (0);
}

#ifdef HAVE_TRACE
/* We may want to make this conditional at runtime. */
static int faultinject_trace_operation(void)
{
	return (1);
}
#endif

static int faultinject_caller_interesting(void)
{
	unw_cursor_t cursor;
	unw_context_t uc;
	unw_word_t offp;
	char fn_name[256];
	int count, ret;

	/* Avoid fall-injecting recursively inside this particular function */
	static int in_fi_func = 0;
	if (in_fi_func == 1)
		return (0);
	in_fi_func = 1;

	ret = 0;
	if (g_library_trace_substring == NULL) {
		ret = 1;
		goto end;
	}

	if (0 != unw_getcontext(&uc))
		goto end;

	if (0 != unw_init_local(&cursor, &uc))
		goto end;

	count = 10;	/* Check a max depth of 10 callers */
	while (unw_step(&cursor) > 0 && count > 0) {
		fn_name[0] = '\0';
		if (0 == unw_get_proc_name(&cursor, fn_name, 256, &offp) &&
		    0 != strlen(fn_name)) {
			if (strstr(fn_name, g_library_trace_substring) != NULL) {
				ret = 1;
				goto end;
			}
		}
		count--;
	}

end:
	in_fi_func = 0;
	return (ret);
}

FUNCTION_DEFINITIONS@
