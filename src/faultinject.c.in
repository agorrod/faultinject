#include "config.h"

#undef _FILE_OFFSET_BITS
#undef __USE_FILE_OFFSET64
#undef _GNU_SOURCE
#define _GNU_SOURCE
#include <dirent.h>
#include <dlfcn.h>
#include <errno.h>
#include <execinfo.h>
#include <fcntl.h>
#include <pthread.h>
#include <stdarg.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/mman.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#define	FAULT_INJECT_API	__attribute__ ((visibility("default")))

/*
 * Save references to the C library implementations of the functions we are
 * overriding.
 */
@TYPEDEFS@

@FUNCTION_DECLARATIONS@

static char *g_library_trace_substring = NULL;
static uint64_t g_op_count = 0;
static uint64_t g_max_op_count = 0;

@GLOBAL_CONFIG_DECLARATIONS@

void __attribute__ ((constructor)) faultinject_constructor(void);

/*
 * Setup pointers to the C library version of functions we are overriding,
 * and initialize any global variables.
 */
void __attribute__ ((constructor)) faultinject_constructor(void)
{
	char *env_string, *err_string;

	env_string = err_string = NULL;
	errno = 0;

	fprintf(stderr, "Setting up fault injector\n");
@CONSTRUCTOR_ASSIGNMENTS@

	if ((env_string = getenv("FAULTINJECT_LIBRARY_NAME")) != NULL &&
	    strlen(env_string) != 0) {
		g_library_trace_substring = env_string;
	}

	if ((env_string = getenv("FAULTINJECT_FAIL_COUNT")) != NULL &&
	    strlen(env_string) != 0) {
		errno = 0;
		g_max_op_count = strtoull(env_string, NULL, 10);
		printf("Set max op count to: %d\n", (int)g_max_op_count);
		if (errno != 0) {
			fprintf(stderr, "Failed to parse environment variable\n");
			g_max_op_count = 0;
		}
	}
	/* Function specific environment variable configuration parsing. */
@CONSTRUCTOR_CONFIG@
}

static int faultinject_fail_operation(void)
{
	if (!libc_open)
		faultinject_constructor();

	if (g_max_op_count > 0 && ++g_op_count > g_max_op_count) {
		printf("failing with op count: %d\n", (int)g_op_count);
		return (EFAULT);
	}

@OPERATION_CHECK@

	return (0);
}

#ifdef HAVE_TRACE
/* We may want to make this conditional at runtime. */
static int faultinject_trace_operation(void)
{
	return (1);
}
#endif

static int faultinject_caller_interesting(void)
{
	char **stack_symbols;
	int found, i, num_stacks;
	void *stack_buf[10]; /* Only search up to ten stacks deep */

	if (g_library_trace_substring == NULL)
		return (1);

	if ((num_stacks = backtrace(&stack_buf[0], 10)) == 0)
		return (0);

	if ((stack_symbols = backtrace_symbols(&stack_buf[0], num_stacks)) == NULL)
		return (0);

	for (i = 0, found = 0; i < num_stacks; i++) {
		if (strstr(stack_symbols[i], g_library_trace_substring) != NULL) {
			found = 1;
			break;
		}
	}
	free(stack_symbols);
	return (found);
}

@FUNCTION_DEFINITIONS@
